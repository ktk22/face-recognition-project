# -*- coding: utf-8 -*-
"""Another copy of Welcome To Colaboratory

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wF9vLynER66cbmH_Gfx9qDflMEzm_BZi
"""

!pip install opencv-python
!pip install dlib
!pip install pyheif
!pip install pyheif-pillow-opener

import cv2
import dlib
import numpy as np
from google.colab import files
from IPython.display import display, Image as IPImage
from PIL import Image as PILImage
import io
import pyheif

def heic_to_jpeg(heic_data):
    heif_file = pyheif.read(heic_data)
    image = Image.frombytes(
        heif_file.mode,
        heif_file.size,
        heif_file.data,
        "raw",
        heif_file.mode,
        heif_file.stride,
    )
    image = np.array(image)
    return cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

def detect_and_display_faces(image_data):
    detector = dlib.get_frontal_face_detector()
    image = heic_to_jpeg(image_data)

    if image is None:
        print("Không thể chuyển đổi ảnh từ HEIC sang JPEG.")
        return

    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    faces = detector(gray)

    if len(faces) == 0:
        print("Không tìm thấy khuôn mặt trong ảnh.")
        return

    for face in faces:
        x, y, w, h = face.left(), face.top(), face.width(), face.height()
        face_image = image[y:y+h, x:x+w]
        display_image(face_image)

def display_image(image):
    _, encoded_image = cv2.imencode('.jpg', image)
    display(IPImage(data=encoded_image))

def select_image_and_detect_faces():
    uploaded = files.upload()
    for filename in uploaded.keys():
        detect_and_display_faces(uploaded[filename])

if __name__ == "__main__":
    select_image_and_detect_faces()

from IPython.display import display, Javascript, Image as IPImage
from google.colab.output import eval_js
from base64 import b64decode
import cv2
import dlib
import numpy as np

def heic_to_jpeg(heic_data):
    heif_file = pyheif.read(heic_data)
    image = PILImage.frombytes(
        heif_file.mode,
        heif_file.size,
        heif_file.data,
        "raw",
        heif_file.mode,
        heif_file.stride,
    )
    image = np.array(image)
    return cv2.cvtColor(image, cv2.COLOR_RGB2BGR)

def detect_faces(image):
    detector = dlib.get_frontal_face_detector()
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    faces = detector(gray)
    return faces

def display_image(image):
    _, encoded_image = cv2.imencode('.jpg', image)
    display(IPImage(data=encoded_image))

def calculate_euclidean_distance(face1, face2):
    if type(face1) != np.ndarray or type(face2) != np.ndarray:
        print("Đối số không phải là mảng NumPy.")
        return None

    if face1.size == 0 or face2.size == 0:
        print("Đối số không có giá trị.")
        return None

    # Chuyển đổi kích thước của ảnh để phù hợp với mô hình nhận diện khuôn mặt
    face1_resized = cv2.resize(face1, (128, 128))
    face2_resized = cv2.resize(face2, (128, 128))

    # Tính toán độ lệch Euclidean giữa hai khuôn mặt
    distance = np.linalg.norm(face1_resized - face2_resized)
    return distance


def take_photo(filename='photo.jpg', quality=0.8):
    js = Javascript('''
        async function takePhoto(quality) {
          const div = document.createElement('div');
          const capture = document.createElement('button');
          capture.textContent = 'Capture';
          div.appendChild(capture);

          const video = document.createElement('video');
          video.style.display = 'block';
          const stream = await navigator.mediaDevices.getUserMedia({video: true});

          document.body.appendChild(div);
          div.appendChild(video);
          video.srcObject = stream;
          await video.play();

          // Resize the output to fit the video element.
          google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

          // Wait for Capture to be clicked.
          await new Promise((resolve) => capture.onclick = resolve);

          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          canvas.getContext('2d').drawImage(video, 0, 0);
          stream.getVideoTracks()[0].stop();
          div.remove();
          return canvas.toDataURL('image/jpeg', quality);
        }
        ''')

    display(js)
    data = eval_js('takePhoto({})'.format(quality))
    binary = b64decode(data.split(',')[1])
    with open(filename, 'wb') as f:
        f.write(binary)

    # Detect faces in the captured image
    uploaded_image_data = cv2.imread(filename)
    uploaded_image_faces = detect_faces(uploaded_image_data)

    return filename, uploaded_image_faces


def detect_and_display_faces(filename='photo.jpg', uploaded_image_faces=None):
    uploaded_image_data = cv2.imread(filename)
    if uploaded_image_data is None:
        print("Không thể đọc ảnh.")
        return

    if uploaded_image_faces is None:
        uploaded_image_faces = detect_faces(uploaded_image_data)

    if len(uploaded_image_faces) > 0:
        print("Đã nhận diện khuôn mặt trên ảnh từ camera.")
        display_image(uploaded_image_data)
        return uploaded_image_faces[0]
    else:
        print("Không tìm thấy khuôn mặt trên ảnh từ camera.")
        return None

def main():
    filename, uploaded_image_faces = take_photo()  # Lấy tên file và danh sách các khuôn mặt từ hàm take_photo
    print('Ảnh đã được lưu tại {}'.format(filename))

    # Chụp ảnh từ camera và hiển thị khuôn mặt đã nhận diện
    current_image_face = detect_and_display_faces(filename, uploaded_image_faces)

    if current_image_face is not None:
        # Tính toán khoảng cách Euclidean giữa khuôn mặt từ ảnh trước và khuôn mặt từ camera
        euclidean_distance = calculate_euclidean_distance(uploaded_image_faces[0], current_image_face)
        print("Khoảng cách Euclidean giữa hai khuôn mặt:", euclidean_distance)


if __name__ == "__main__":
    main()

import cv2
import dlib
import numpy as np
from google.colab import files
from IPython.display import display, Image as IPImage
from PIL import Image as PILImage
import io
import pyheif
from IPython.display import Javascript
from google.colab.output import eval_js
from base64 import b64decode

def heic_to_jpeg(heic_data):
    heif_file = pyheif.read(heic_data)
    image = PILImage.frombytes(
        heif_file.mode,
        heif_file.size,
        heif_file.data,
        "raw",
        heif_file.mode,
        heif_file.stride,
    )
    image = np.array(image)
    return cv2.cvtColor(image, cv2.COLOR_RGB2BGR)

def detect_faces(image):
    detector = dlib.get_frontal_face_detector()
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    faces = detector(gray)
    return faces

def display_image(image):
    _, encoded_image = cv2.imencode('.jpg', image)
    display(IPImage(data=encoded_image))

def calculate_euclidean_distance(face1, face2):
    if type(face1) != np.ndarray or type(face2) != np.ndarray:
        print("Đối số không phải là mảng NumPy.")
        return None

    if face1.size == 0 or face2.size == 0:
        print("Đối số không có giá trị.")
        return None

    # Chuyển đổi kích thước của ảnh để phù hợp với mô hình nhận diện khuôn mặt
    face1_resized = cv2.resize(face1, (128, 128))
    face2_resized = cv2.resize(face2, (128, 128))

    # Tính toán độ lệch Euclidean giữa hai khuôn mặt
    distance = np.linalg.norm(face1_resized - face2_resized)
    return distance

def detect_faces_in_cccd_image(filename):
    # Đọc ảnh từ file
    with open(filename, 'rb') as f:
        cccd_image_data = f.read()

    heic_image = heic_to_jpeg(cccd_image_data)
    if heic_image is None:
        print("Không thể chuyển đổi ảnh từ HEIC sang JPEG.")
        return None, None

    # Nhận diện khuôn mặt trong ảnh
    faces = detect_faces(heic_image)

    if len(faces) > 0:
        print("Đã nhận diện khuôn mặt trong ảnh CCD.")
        return heic_image, faces  # Trả về ảnh và danh sách khuôn mặt
    else:
        print("Không tìm thấy khuôn mặt trong ảnh CCD.")
        return None, None


def take_photo(filename='photo.jpg', quality=0.8):
    js = Javascript('''
        async function takePhoto(quality) {
          const div = document.createElement('div');
          const capture = document.createElement('button');
          capture.textContent = 'Capture';
          div.appendChild(capture);

          const video = document.createElement('video');
          video.style.display = 'block';
          const stream = await navigator.mediaDevices.getUserMedia({video: true});

          document.body.appendChild(div);
          div.appendChild(video);
          video.srcObject = stream;
          await video.play();

          // Resize the output to fit the video element.
          google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

          // Wait for Capture to be clicked.
          await new Promise((resolve) => capture.onclick = resolve);

          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          canvas.getContext('2d').drawImage(video, 0, 0);
          stream.getVideoTracks()[0].stop();
          div.remove();
          return canvas.toDataURL('image/jpeg', quality);
        }
        ''')

    display(js)
    data = eval_js('takePhoto({})'.format(quality))
    binary = b64decode(data.split(',')[1])
    with open(filename, 'wb') as f:
        f.write(binary)
    return filename

def detect_and_display_faces_from_camera(cccd_image_data, cccd_faces, quality=0.8):
    filename = 'photo.jpg'
    take_photo(filename, quality)

    # Đọc ảnh từ camera và nhận diện khuôn mặt
    uploaded_image_data = cv2.imread(filename)
    uploaded_image_faces = detect_faces(uploaded_image_data)

    if len(uploaded_image_faces) > 0:
        print("Đã nhận diện khuôn mặt trên ảnh từ camera.")
        display_image(uploaded_image_data)
        current_image_face = uploaded_image_faces[0]
    else:
        print("Không tìm thấy khuôn mặt trên ảnh từ camera.")
        current_image_face = None

    if cccd_faces is not None and current_image_face is not None:
        # Tính toán khoảng cách Euclidean giữa khuôn mặt từ ảnh trước và khuôn mặt từ camera
        euclidean_distance = calculate_euclidean_distance(cccd_faces[0], current_image_face)
        print("Khoảng cách Euclidean giữa hai khuôn mặt:", euclidean_distance)

    # Hiển thị phần cắt của ảnh CCD
    if cccd_faces is not None:
        for face in cccd_faces:
            x, y, w, h = face.left(), face.top(), face.width(), face.height()
            face_image = cccd_image_data[y:y+h, x:x+w]
            print("Phần cắt của ảnh CCD:")
            display_image(face_image)


def main():
    # Chọn ảnh từ CCD và nhận diện khuôn mặt
    uploaded_cccd_image = files.upload()
    for filename in uploaded_cccd_image.keys():
        cccd_image_data, cccd_faces = detect_faces_in_cccd_image(filename)
        if cccd_image_data is not None and cccd_faces is not None:
            print('Ảnh CCD đã được chọn:', filename)
            detect_and_display_faces_from_camera(cccd_image_data, cccd_faces)

if __name__ == "__main__":
    main()

import cv2
import dlib
import numpy as np
from google.colab import files
from IPython.display import display, Image as IPImage
from PIL import Image as PILImage
import io
import pyheif
from IPython.display import Javascript
from google.colab.output import eval_js
from base64 import b64decode

def heic_to_jpeg(heic_data):
    heif_file = pyheif.read(heic_data)
    image = PILImage.frombytes(
        heif_file.mode,
        heif_file.size,
        heif_file.data,
        "raw",
        heif_file.mode,
        heif_file.stride,
    )
    image = np.array(image)
    return cv2.cvtColor(image, cv2.COLOR_RGB2BGR)

def detect_faces(image):
    detector = dlib.get_frontal_face_detector()
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    faces = detector(gray)
    return faces

def display_image(image):
    _, encoded_image = cv2.imencode('.jpg', image)
    display(IPImage(data=encoded_image))

def calculate_euclidean_distance(face1, face2):
    if type(face1) != np.ndarray or type(face2) != np.ndarray:
        print("Đối số không phải là mảng NumPy.")
        return None

    if face1.size == 0 or face2.size == 0:
        print("Đối số không có giá trị.")
        return None

    # Chuyển đổi kích thước của ảnh để phù hợp với mô hình nhận diện khuôn mặt
    face1_resized = cv2.resize(face1, (128, 128))
    face2_resized = cv2.resize(face2, (128, 128))

    # Tính toán độ lệch Euclidean giữa hai khuôn mặt
    distance = np.linalg.norm(face1_resized - face2_resized)
    return distance

def detect_faces_in_cccd_image(filename):
    # Đọc ảnh từ file
    with open(filename, 'rb') as f:
        cccd_image_data = f.read()

    heic_image = heic_to_jpeg(cccd_image_data)
    if heic_image is None:
        print("Không thể chuyển đổi ảnh từ HEIC sang JPEG.")
        return None, None

    # Nhận diện khuôn mặt trong ảnh
    faces = detect_faces(heic_image)

    if len(faces) > 0:
        print("Đã nhận diện khuôn mặt trong ảnh CCD.")
        return heic_image, faces  # Trả về ảnh và danh sách khuôn mặt
    else:
        print("Không tìm thấy khuôn mặt trong ảnh CCD.")
        return None, None


def take_photo(filename='photo.jpg', quality=0.8):
    js = Javascript('''
        async function takePhoto(quality) {
          const div = document.createElement('div');
          const capture = document.createElement('button');
          capture.textContent = 'Capture';
          div.appendChild(capture);

          const video = document.createElement('video');
          video.style.display = 'block';
          const stream = await navigator.mediaDevices.getUserMedia({video: true});

          document.body.appendChild(div);
          div.appendChild(video);
          video.srcObject = stream;
          await video.play();

          // Resize the output to fit the video element.
          google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

          // Wait for Capture to be clicked.
          await new Promise((resolve) => capture.onclick = resolve);

          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          canvas.getContext('2d').drawImage(video, 0, 0);
          stream.getVideoTracks()[0].stop();
          div.remove();
          return canvas.toDataURL('image/jpeg', quality);
        }
        ''')

    display(js)
    data = eval_js('takePhoto({})'.format(quality))
    binary = b64decode(data.split(',')[1])
    with open(filename, 'wb') as f:
        f.write(binary)
    return filename

def detect_and_display_faces_from_camera(cccd_image_data, cccd_faces, quality=0.8, use_camera=True):
    if use_camera:
        filename = 'photo.jpg'
        take_photo(filename, quality)

        # Đọc ảnh từ camera và nhận diện khuôn mặt
        uploaded_image_data = cv2.imread(filename)
    else:
        uploaded = files.upload()
        for filename in uploaded.keys():
            uploaded_image_data = cv2.imread(filename)
            if uploaded_image_data is None:
                print("Không thể đọc ảnh từ file.")
                return
            print('Ảnh từ file đã được chọn:', filename)

    uploaded_image_faces = detect_faces(uploaded_image_data)

    if len(uploaded_image_faces) > 0:
        print("Đã nhận diện khuôn mặt trên ảnh.")
        display_image(uploaded_image_data)
        current_image_face = uploaded_image_faces[0]
    else:
        print("Không tìm thấy khuôn mặt trên ảnh.")
        current_image_face = None

    # Hiển thị phần cắt của ảnh CCD và phần cắt của ảnh từ camera
    if cccd_faces is not None:
        for face in cccd_faces:
            x, y, w, h = face.left(), face.top(), face.width(), face.height()
            face_image = cccd_image_data[y:y+h, x:x+w]
            print("Phần cắt của ảnh CCD:")
            display_image(face_image)

            # Chuyển đổi face_image thành mảng NumPy
            face_image_np = np.array(face_image)

            # Chuyển đổi current_image_face thành mảng NumPy
            current_image_face_np = np.array(uploaded_image_data[y:y+h, x:x+w])

            # Tính toán khoảng cách Euclidean giữa khuôn mặt từ ảnh cắt và khuôn mặt từ camera
            if current_image_face is not None:
                if face_image_np.shape == current_image_face_np.shape:  # Kiểm tra kích thước hình ảnh
                    euclidean_distance = calculate_euclidean_distance(face_image_np, current_image_face_np)
                    if euclidean_distance is not None:
                        print("Khoảng cách Euclidean giữa hai khuôn mặt:", euclidean_distance)
                        # Đánh giá độ chính xác
                        if euclidean_distance < 10:  # Điều chỉnh ngưỡng tùy theo yêu cầu của bạn
                            print("Khuôn mặt từ ảnh cắt khớp với khuôn mặt từ ảnh.")
                        else:
                            print("Khuôn mặt từ ảnh cắt không khớp với khuôn mặt từ ảnh.")
                else:
                    print("Kích thước của hai khuôn mặt không khớp.")

    # Vẽ khung hình xung quanh khuôn mặt từ ảnh camera
    for face in uploaded_image_faces:
        x, y, w, h = face.left(), face.top(), face.width(), face.height()
        cv2.rectangle(uploaded_image_data, (x, y), (x + w, y + h), (255, 0, 0), 2)

    # Hiển thị ảnh từ camera sau khi vẽ khung hình
    display_image(uploaded_image_data)


def main():
    # Chọn ảnh từ CCD và nhận diện khuôn mặt
    uploaded_cccd_image = files.upload()
    for filename in uploaded_cccd_image.keys():
        cccd_image_data, cccd_faces = detect_faces_in_cccd_image(filename)
        if cccd_image_data is not None and cccd_faces is not None:
            print('Ảnh CCD đã được chọn:', filename)

            # Sau khi nhận diện khuôn mặt từ ảnh CCD, tiến hành nhận diện khuôn mặt từ camera
            # và so sánh với khuôn mặt từ ảnh CCD
            detect_and_display_faces_from_camera(cccd_image_data, cccd_faces, use_camera=True)

if __name__ == "__main__":
    main()

import cv2
import dlib
import numpy as np
from google.colab import files
from IPython.display import display, Image as IPImage
from PIL import Image as PILImage
import io
import pyheif
from IPython.display import Javascript
from google.colab.output import eval_js
from base64 import b64decode

def heic_to_jpeg(heic_data):
    heif_file = pyheif.read(heic_data)
    image = PILImage.frombytes(
        heif_file.mode,
        heif_file.size,
        heif_file.data,
        "raw",
        heif_file.mode,
        heif_file.stride,
    )
    image = np.array(image)
    return cv2.cvtColor(image, cv2.COLOR_RGB2BGR)

def detect_faces(image):
    detector = dlib.get_frontal_face_detector()
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    faces = detector(gray)
    return faces

def display_image(image):
    _, encoded_image = cv2.imencode('.jpg', image)
    display(IPImage(data=encoded_image))

def calculate_euclidean_distance(face1, face2):
    if type(face1) != np.ndarray or type(face2) != np.ndarray:
        print("Đối số không phải là mảng NumPy.")
        return None

    if face1.size == 0 or face2.size == 0:
        print("Đối số không có giá trị.")
        return None

    # Chuyển đổi kích thước của ảnh để phù hợp với mô hình nhận diện khuôn mặt
    face1_resized = cv2.resize(face1, (128, 128))
    face2_resized = cv2.resize(face2, (128, 128))

    # Tính toán độ lệch Euclidean giữa hai khuôn mặt
    distance = np.linalg.norm(face1_resized - face2_resized)
    return distance

def detect_faces_in_cccd_image(filename):
    # Đọc ảnh từ file
    with open(filename, 'rb') as f:
        cccd_image_data = f.read()

    heic_image = heic_to_jpeg(cccd_image_data)
    if heic_image is None:
        print("Không thể chuyển đổi ảnh từ HEIC sang JPEG.")
        return None, None

    # Nhận diện khuôn mặt trong ảnh
    faces = detect_faces(heic_image)

    if len(faces) > 0:
        print("Đã nhận diện khuôn mặt trong ảnh CCD.")
        return heic_image, faces  # Trả về ảnh và danh sách khuôn mặt
    else:
        print("Không tìm thấy khuôn mặt trong ảnh CCD.")
        return None, None


def take_photo(filename='photo.jpg', quality=0.8):
    js = Javascript('''
        async function takePhoto(quality) {
          const div = document.createElement('div');
          const capture = document.createElement('button');
          capture.textContent = 'Capture';
          div.appendChild(capture);

          const video = document.createElement('video');
          video.style.display = 'block';
          const stream = await navigator.mediaDevices.getUserMedia({video: true});

          document.body.appendChild(div);
          div.appendChild(video);
          video.srcObject = stream;
          await video.play();

          // Resize the output to fit the video element.
          google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

          // Wait for Capture to be clicked.
          await new Promise((resolve) => capture.onclick = resolve);

          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          canvas.getContext('2d').drawImage(video, 0, 0);
          stream.getVideoTracks()[0].stop();
          div.remove();
          return canvas.toDataURL('image/jpeg', quality);
        }
        ''')

    display(js)
    data = eval_js('takePhoto({})'.format(quality))
    binary = b64decode(data.split(',')[1])
    with open(filename, 'wb') as f:
        f.write(binary)
    return filename
def detect_and_display_faces_from_camera(cccd_image_data, cccd_faces, quality=0.8, use_camera=True):
    if use_camera:
        filename = 'photo.jpg'
        take_photo(filename, quality)

        # Đọc ảnh từ camera và nhận diện khuôn mặt
        uploaded_image_data = cv2.imread(filename)
    else:
        uploaded = files.upload()
        for filename in uploaded.keys():
            uploaded_image_data = cv2.imread(filename)
            if uploaded_image_data is None:
                print("Không thể đọc ảnh từ file.")
                return
            print('Ảnh từ file đã được chọn:', filename)

    uploaded_image_faces = detect_faces(uploaded_image_data)

    if len(uploaded_image_faces) > 0:
        print("Đã nhận diện khuôn mặt trên ảnh.")
        display_image(uploaded_image_data)
        current_image_face = uploaded_image_faces[0]
    else:
        print("Không tìm thấy khuôn mặt trên ảnh.")
        current_image_face = None

    # Hiển thị phần cắt của ảnh từ camera
    if current_image_face is not None:
        x, y, w, h = current_image_face.left(), current_image_face.top(), current_image_face.width(), current_image_face.height()
        print("Phần cắt của ảnh từ camera:")
        display_image(uploaded_image_data[y:y+h, x:x+w])

    # Hiển thị phần cắt của ảnh CCD và phần cắt của ảnh từ camera
    if cccd_faces is not None:
        for face in cccd_faces:
            x, y, w, h = face.left(), face.top(), face.width(), face.height()
            face_image = cccd_image_data[y:y+h, x:x+w]
            print("Phần cắt của ảnh CCD:")
            display_image(face_image)

            # Chuyển đổi face_image thành mảng NumPy
            face_image_np = np.array(face_image)

            # Chuyển đổi current_image_face thành mảng NumPy
            current_image_face_np = np.array(uploaded_image_data[y:y+h, x:x+w])

            # Tính toán khoảng cách Euclidean giữa khuôn mặt từ ảnh cắt và khuôn mặt từ camera
            if current_image_face is not None:
                if face_image_np.shape == current_image_face_np.shape:  # Kiểm tra kích thước hình ảnh
                    euclidean_distance = calculate_euclidean_distance(face_image_np, current_image_face_np)
                    if euclidean_distance is not None:
                        print("Khoảng cách Euclidean giữa hai khuôn mặt:", euclidean_distance)
                        # Đánh giá độ chính xác
                        threshold = 10  # Ngưỡng
                        if euclidean_distance < threshold:
                            accuracy = 100 - (euclidean_distance / threshold) * 100
                            print("Khuôn mặt từ ảnh cắt khớp với khuôn mặt từ ảnh với độ chính xác là {:.2f}%.".format(accuracy))
                        else:
                            print("Khuôn mặt từ ảnh cắt không khớp với khuôn mặt từ ảnh.")
                else:
                    print("Kích thước của hai khuôn mặt không khớp.")

    # Vẽ khung hình xung quanh khuôn mặt từ ảnh camera
    for face in uploaded_image_faces:
        x, y, w, h = face.left(), face.top(), face.width(), face.height()
        cv2.rectangle(uploaded_image_data, (x, y), (x + w, y + h), (255, 0, 0), 2)

    # Hiển thị ảnh từ camera sau khi vẽ khung hình
    display_image(uploaded_image_data)




def main():
    # Chọn ảnh từ CCD và nhận diện khuôn mặt
    uploaded_cccd_image = files.upload()
    for filename in uploaded_cccd_image.keys():
        cccd_image_data, cccd_faces = detect_faces_in_cccd_image(filename)
        if cccd_image_data is not None and cccd_faces is not None:
            print('Ảnh CCD đã được chọn:', filename)

            # Sau khi nhận diện khuôn mặt từ ảnh CCD, tiến hành nhận diện khuôn mặt từ camera
            # và so sánh với khuôn mặt từ ảnh CCD
            detect_and_display_faces_from_camera(cccd_image_data, cccd_faces, use_camera=True)

if __name__ == "__main__":
    main()

import cv2
import dlib
import numpy as np
from google.colab import files
from IPython.display import display, Image as IPImage
from PIL import Image as PILImage
import io
import pyheif
from IPython.display import Javascript
from google.colab.output import eval_js
from base64 import b64decode

def heic_to_jpeg(heic_data):
    heif_file = pyheif.read(heic_data)
    image = PILImage.frombytes(
        heif_file.mode,
        heif_file.size,
        heif_file.data,
        "raw",
        heif_file.mode,
        heif_file.stride,
    )
    image = np.array(image)
    return cv2.cvtColor(image, cv2.COLOR_RGB2BGR)

def detect_faces(image):
    detector = dlib.get_frontal_face_detector()
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    faces = detector(gray)
    return faces

def display_image(image):
    _, encoded_image = cv2.imencode('.jpg', image)
    display(IPImage(data=encoded_image))

def calculate_euclidean_distance(face1, face2):
    if type(face1) != np.ndarray or type(face2) != np.ndarray:
        print("Đối số không phải là mảng NumPy.")
        return None

    if face1.size == 0 or face2.size == 0:
        print("Đối số không có giá trị.")
        return None

    # Chuyển đổi kích thước của ảnh để phù hợp với mô hình nhận diện khuôn mặt
    face1_resized = cv2.resize(face1, (128, 128))
    face2_resized = cv2.resize(face2, (128, 128))

    # Tính toán độ lệch Euclidean giữa hai khuôn mặt
    distance = np.linalg.norm(face1_resized - face2_resized)
    return distance

def detect_faces_in_cccd_image(filename):
    # Đọc ảnh từ file
    with open(filename, 'rb') as f:
        cccd_image_data = f.read()

    heic_image = heic_to_jpeg(cccd_image_data)
    if heic_image is None:
        print("Không thể chuyển đổi ảnh từ HEIC sang JPEG.")
        return None, None

    # Nhận diện khuôn mặt trong ảnh
    faces = detect_faces(heic_image)

    if len(faces) > 0:
        print("Đã nhận diện khuôn mặt trong ảnh CCD.")
        return heic_image, faces  # Trả về ảnh và danh sách khuôn mặt
    else:
        print("Không tìm thấy khuôn mặt trong ảnh CCD.")
        return None, None


def detect_and_display_faces_from_camera(cccd_image_data, cccd_faces, quality=0.8, use_camera=True):
    if use_camera:
        filename = 'photo.jpg'
        take_photo(filename, quality)

        # Đọc ảnh từ camera và nhận diện khuôn mặt
        uploaded_image_data = cv2.imread(filename)
    else:
        uploaded = files.upload()
        for filename in uploaded.keys():
            uploaded_image_data = cv2.imread(filename)
            if uploaded_image_data is None:
                print("Không thể đọc ảnh từ file.")
                return
            print('Ảnh từ file đã được chọn:', filename)

    uploaded_image_faces = detect_faces(uploaded_image_data)

    if len(uploaded_image_faces) > 0:
        print("Đã nhận diện khuôn mặt trên ảnh.")
        display_image(uploaded_image_data)
        current_image_face = uploaded_image_faces[0]
    else:
        print("Không tìm thấy khuôn mặt trên ảnh.")
        current_image_face = None

    # Hiển thị phần cắt của ảnh từ camera chứa mặt
    if current_image_face is not None:
        x, y, w, h = current_image_face.left(), current_image_face.top(), current_image_face.width(), current_image_face.height()
        face_image = uploaded_image_data[y:y+h, x:x+w]
        print("Phần cắt của ảnh từ camera:")
        display_image(face_image)

        # Chuyển đổi face_image thành mảng NumPy
        face_image_np = np.array(face_image)

        # Hiển thị phần cắt của ảnh từ CCD
        if cccd_faces is not None:
            for face in cccd_faces:
                x, y, w, h = face.left(), face.top(), face.width(), face.height()
                face_image_cccd = cccd_image_data[y:y+h, x:x+w]
                print("Phần cắt của ảnh từ CCD:")
                display_image(face_image_cccd)

                # Chuyển đổi face_image_cccd thành mảng NumPy
                face_image_cccd_np = np.array(face_image_cccd)

                # Tính toán khoảng cách Euclidean giữa khuôn mặt từ ảnh cắt và khuôn mặt từ camera
                euclidean_distance = calculate_euclidean_distance(face_image_np, face_image_cccd_np)
                if euclidean_distance is not None:
                    print("Khoảng cách Euclidean giữa hai khuôn mặt:", euclidean_distance)
                    # Đánh giá độ chính xác
                    threshold = 10  # Ngưỡng
                    similarity = max(0, 100 - (euclidean_distance / threshold) * 100)  # Tính độ tương đồng
                    print("Khuôn mặt từ ảnh cắt khớp với khuôn mặt từ ảnh với độ tương đồng là {:.2f}%.".format(similarity))
    else:
        print("Không tìm thấy khuôn mặt từ camera.")




def main():
    # Chọn ảnh từ CCD và nhận diện khuôn mặt
    uploaded_cccd_image = files.upload()
    for filename in uploaded_cccd_image.keys():
        cccd_image_data, cccd_faces = detect_faces_in_cccd_image(filename)
        if cccd_image_data is not None and cccd_faces is not None:
            print('Ảnh CCD đã được chọn:', filename)

            # Sau khi nhận diện khuôn mặt từ ảnh CCD, tiến hành nhận diện khuôn mặt từ camera
            # và so sánh với khuôn mặt từ ảnh CCD
            detect_and_display_faces_from_camera(cccd_image_data, cccd_faces, use_camera=True)

if __name__ == "__main__":
    main()

!git

!git init

!git clone https://github.com/ktk22/face-recognition-project.git

! pwd

# Commented out IPython magic to ensure Python compatibility.
# %cd face-recognition-project/

